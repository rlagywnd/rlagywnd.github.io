---
title: 소켓
category: NetWork
tag: [ComputerScience,NetWork,C++]  
sidebar:
    nav: "docs" 
---


## 1. 소켓이란 무엇인가?

소켓(Socket)은 한마디로 **네트워크 통신을 위한 특별한 통로**라고 생각할 수 있다. 마치 우리가 전화기를 이용해 다른 사람과 소통하듯이, 프로그램은 **소켓**이라는 것을 이용해 다른 프로그램과 데이터를 주고받는다. 소켓은 응용 프로그램과 네트워크 통신이 이루어지는 지점을 추상화한 개념이다.

이러한 소켓은 프로그래밍적으로 볼 때, **파일 디스크립터(File Descriptor)**나 **핸들(Handle)**과 유사한 개념이었다. 파일에 데이터를 읽고 쓰는 것처럼, 소켓에 데이터를 보내고(send) 받으며(receive) 통신이 이루어졌기 때문이다.

### 1.1. 파일 입출력과 소켓 통신의 유사성

아래 예시 코드를 보면, 파일 입출력과 소켓 통신이 얼마나 유사한 방식으로 동작하는지 알 수 있다.

```cpp
// (a) 리눅스 파일 입출력
int fd = open("myfile", ...); // 파일 생성 
read(fd, ...); // 데이터 읽기
write(fd, ...); // 데이터 쓰기

// (b) 윈도우 소켓 통신
SOCKET sock = socket(...); // 소켓 생성 
recv(sock, ...); // 데이터 받기
send(sock, ...); // 데이터 보내기
````

두 작업 방식이 매우 유사하다는 것을 알 수 있다. 소켓을 생성하고 설정을 마치면, 운영체제가 관리하는 통신 관련 정보를 참조하여 손쉽게 데이터를 주고받는 작업이 가능해졌다.

-----

## 2\. 소켓 통신의 기본 원리: 전화 통신과 비교하기

소켓 통신은 일반적인 전화 통신과 매우 비슷한 원리로 동작한다. 이 개념을 전화 통신에 비유하면 쉽게 이해할 수 있다.

### 2.1. 단순한 통신 개념

가장 단순한 전화 통신을 생각해보자. 두 사람이 전화기를 통해 서로 연결되어 대화하는 것과 같다. 프로그램 세계에서는 **응용 프로그램**이 **소켓**이라는 통로를 통해 **인터넷** 너머의 다른 프로그램과 연결되어 데이터를 주고받는다고 볼 수 있다.

### 2.2. IP 주소와 포트 번호의 역할

현실 세계에 수많은 전화기가 존재하듯이, 인터넷에는 수많은 응용 프로그램이 존재한다. 이들을 명확하게 구분하고 연결하기 위해 **IP 주소**와 **포트 번호**가 필요하다.

  * **IP 주소 (Internet Protocol Address):** 마치 도시나 건물에 부여된 **대표 전화번호**와 같다. 이는 인터넷에 연결된 컴퓨터나 기기를 고유하게 식별한다.
  * **포트 번호 (Port Number):** 이는 건물 내의 특정 부서나 사람에게 연결되는 **내선 번호**와 같다. 한 컴퓨터 내에서 여러 프로그램이 동시에 네트워크를 사용하고 있을 때, 포트 번호를 통해 어떤 프로그램과 통신할지 정확히 지정할 수 있다.

결론적으로, 소켓은 **IP 주소**와 **포트 번호**를 결합한 개념으로, 통신하려는 특정 응용 프로그램을 정확히 가리키는 주소 역할을 하게 된다. 클라이언트와 서버는 서로의 소켓이 연결되었다고 생각하며 데이터를 주고받는다. 


소켓 통신에서 IP 주소와 포트 번호의 역할을 이해하는 가장 쉬운 방법은 아파트에 비유하는 것이다.

여러 아파트 단지가 모여 있는 거대한 도시에 배달을 시킨다고 생각해보자. 배달을 받기 위해 우리는 주소를 적는다.
  
- 이때 아파트의 **동**은 IP 주소와 같다. 아파트 단지 내의 수많은 건물 중 배달을 보낼 특정 건물을 찾아내는 역할이다.
  - ex)A 아파트 102동, 103동 등등

- 그리고 **호수**는 포트 번호와 같다. 한 건물에 사는 여러 가구 중 내가 있는 특정한 집을 정확히 가리킨다.
  - ex)A 아파트 103동 1004호 등등

결국, 배달원은 수많은 아파트 중 내가 사는 동을 찾고(IP 주소), 그 동의 여러 집들 중 내 집을 찾아(포트 번호) 배달을 완료하는 것이다.

이와 마찬가지로, 인터넷에서 데이터를 보낼 때, 데이터 패킷은 먼저 수많은 기기 중 통신할 특정 기기(IP 주소)를 찾아간다. 그다음, 해당 기기 내에서 실행 중인 여러 프로그램 중 특정 프로그램(포트 번호)으로 전달되어 통신이 완료된다. 이처럼 IP 주소와 포트 번호는 마치 택배 주소처럼 통신을 정확하고 효율적으로 만드는 핵심 요소이다.

-----

## 3\. 윈도우 소켓 (Winsock) 깊게 파고들기

**윈도우 소켓(Windows Sockets)**, 줄여서 \*\*윈속(Winsock)\*\*은 윈도우 환경에서 네트워크 프로그래밍을 할 수 있도록 만들어진 인터페이스이다. 유닉스에서 개발된 소켓 인터페이스를 윈도우에서 사용할 수 있게 만든 것으로, 윈도우 95 버전부터 공식 API에 포함되었다.

### 3.1. 윈속의 특징과 장점

윈속은 다음과 같은 특징을 가졌다.

  * **DLL 기반:** 대부분의 기능이 DLL(동적 연결 라이브러리)을 통해 제공된다. 따라서 사용하기 전에 초기화(`WSAStartup`) 및 종료(`WSACleanup`) 과정이 필수적이다.
  * **GUI 및 멀티스레드 지원:** 윈도우 프로그램의 특성인 GUI와 멀티스레드 환경에 맞춰 안정적인 동작을 위한 확장 함수들이 존재한다.
  * **다양한 프로토콜 지원:** TCP/IP뿐만 아니라 IPv6, IrDA, Bluetooth 등 여러 프로토콜을 지원하여 최소한의 코드 수정으로 프로토콜을 변경할 수 있었다.

윈속은 다음과 같은 **장점**이 있다.

  * **높은 호환성:** 유닉스 소켓과 소스 코드 수준에서 호환성이 높아, 기존의 코드를 윈도우 환경으로 이식하기 쉬웠다.
  * **널리 사용됨:** 가장 보편적인 네트워크 프로그래밍 인터페이스 중 하나로, 한 번 배워두면 여러 운영체제에서 활용할 수 있었다.
  * **고성능 개발:** 비교적 낮은 수준의 프로그래밍 인터페이스를 제공하여 세부적인 제어가 가능하고, 고성능 네트워크 프로그램 개발에 유리했다.

-----

## 4\. 소켓 프로그래밍의 핵심 과정: 초기화부터 소켓 닫기까지

윈속을 이용한 소켓 프로그래밍은 다음과 같은 공통적인 구조를 따르게 된다.

### 4.1. 윈속 초기화와 종료

윈속을 사용하기 전에는 반드시 초기화 과정을 거쳐야 한다. `WSAStartup()` 함수를 호출하여 윈속 DLL을 초기화하고, 사용을 마친 후에는 `WSACleanup()` 함수를 호출하여 리소스를 해제해야 한다.

```cpp
// 윈속 초기화
int WSAStartup (
    WORD wVersionRequested,
    LPWSADATA IpWSAData
);

// 윈속 종료
int WSACleanup(void);
```

`WSAStartup` 함수는 윈속을 사용하기 위한 필수적인 함수다. 첫 번째 인자로 사용할 윈속 버전을 요청하고, 두 번째 인자로 윈속에 대한 정보를 받을 구조체를 넘겨준다. 성공 시 0을 반환하며, 실패 시에는 오류 코드를 반환한다. `WSACleanup` 함수는 윈속 사용을 종료할 때 호출하며, 성공 시 0을 반환한다.

### 4.2. 소켓 생성과 닫기

윈속이 초기화된 후, `socket()` 함수를 사용하여 소켓을 생성하게 된다. 통신이 완료되면 `closesocket()` 함수를 호출하여 소켓을 닫고, 할당된 시스템 리소스를 반환해주어야 한다.

```cpp
// 소켓 생성
SOCKET socket (
    int af,       // 주소 체계
    int type,     // 소켓 타입
    int protocol  // 프로토콜
);

// 소켓 닫기
int closesocket (
    SOCKET s
);
```

`socket` 함수는 주소 체계, 소켓 타입, 프로토콜을 인자로 받아 새로운 소켓을 반환한다. 성공하면 새로운 소켓 핸들을, 실패하면 `INVALID_SOCKET`을 반환한다. `closesocket` 함수는 소켓 핸들을 인자로 받아 소켓을 닫고, 성공 시 0을 반환한다.

-----

## 5\. 소켓 주소와 바이트 정렬: 데이터 변환의 중요성

네트워크 프로그램에서 주소 정보는 매우 중요하다. IP 주소와 포트 번호를 담는 특별한 구조체와, 데이터 통신을 위한 변환 작업에 대해 알아보자.

### 5.1. 소켓 주소 구조체

네트워크 프로그램에 필요한 주소 정보(IP 주소, 포트 번호 등)를 담는 구조체이다.

  * **`SOCKADDR`:** 소켓 주소의 기본형으로, `sa_family` (주소 체계)와 `sa_data` (주소 정보)로 이루어져 있다.
  * **`SOCKADDR_IN`:** IPv4 주소 전용 구조체로, `sin_family` (AF\_INET), `sin_port`, `sin_addr` (IPv4 주소) 등을 포함한다.
  * **`SOCKADDR_IN6`:** IPv6 주소 전용 구조체이다.

이러한 구조체들은 다양한 소켓 함수의 인자로 사용되며, TCP/IP, IrDA 등 프로토콜 체계에 따라 다른 형태가 존재한다.

### 5.2. 바이트 정렬 (Byte Ordering)의 중요성

컴퓨터의 메모리에 데이터를 저장하는 순서에는 두 가지 방식이 있다. \*\*빅 엔디안(Big-endian)\*\*과 \*\*리틀 엔디안(Little-endian)\*\*이다.

  * **빅 엔디안:** 데이터의 가장 중요한 바이트(최상위 바이트)를 가장 낮은 메모리 주소에 저장하는 방식이다. 네트워크에서 사용하는 표준 방식이다.
  * **리틀 엔디안:** 가장 중요하지 않은 바이트(최하위 바이트)를 가장 낮은 메모리 주소에 저장하는 방식이다. 대부분의 인텔(Intel) 계열 CPU는 이 방식을 사용한다.

서로 다른 바이트 정렬 방식을 사용하는 컴퓨터끼리 통신할 경우, 데이터가 잘못 해석될 수 있다. 따라서 네트워크를 통해 데이터를 주고받을 때는 모든 컴퓨터가 약속된 방식인 \*\*네트워크 바이트 정렬(빅 엔디안)\*\*로 변환하여 데이터를 보내야 한다.

이를 위해 다음과 같은 변환 함수들이 사용된다.

```cpp
// 호스트 바이트 정렬 -> 네트워크 바이트 정렬
u_short htons(u_short hostshort); // host-to-network-short
u_long htonl(u_long hostlong);  // host-to-network-long

// 네트워크 바이트 정렬 -> 호스트 바이트 정렬
u_short ntohs(u_short netshort); // network-to-host-short
u_long ntohl(u_long netlong);  // network-to-host-long
```

`htons`와 `htonl` 함수는 호스트의 바이트 정렬을 네트워크 바이트 정렬로 변환하며, `ntohs`와 `ntohl` 함수는 그 반대의 역할을 한다. 이렇게 변환된 데이터를 소켓 함수에 전달하고, 소켓 함수가 반환한 데이터를 응용 프로그램이 사용하기 전에 다시 호스트 바이트 정렬로 변환하는 과정을 거친다.

### 5.3. IP 주소 및 이름 변환 함수

IP 주소를 사람이 읽기 쉬운 문자열과 컴퓨터가 처리하기 쉬운 숫자 형식으로 변환하는 함수도 제공된다.

```cpp
// 문자열 주소 -> 32비트 숫자 주소
unsigned long inet_addr (const char *cp);

// 32비트 숫자 주소 -> 문자열 주소
char *inet_ntoa (struct in_addr in);
```

또한, 사람이 외우기 쉬운 **도메인 이름**(예: `www.google.com`)을 컴퓨터가 사용하는 **IP 주소**로 변환해주는 **DNS(Domain Name System)** 관련 함수들도 존재한다.

```cpp
// 도메인 이름 -> IP 주소
struct hostent *gethostbyname (
    const char *name // 도메인 이름
);

// IP 주소 -> 도메인 이름
struct hostent *gethostbyaddr (
    const char *addr, // IP 주소(네트워크 바이트 정렬)
    int len,          // IP 주소의 길이
    int type          // 주소 체계(AF_INET 또는 AF_INET6)
);
```

`gethostbyname`과 `gethostbyaddr` 함수는 `hostent`라는 구조체를 반환한다. 이 구조체에는 공식 도메인 이름, 별칭, IP 주소 목록 등이 포함되어 있다. 이 함수들을 통해 프로그램은 도메인 이름만으로도 통신할 상대방의 IP 주소를 알아낼 수 있었다.

-----

### 마치며

소켓 프로그래밍의 기본 개념부터 윈도우 환경에서의 특징, 그리고 주소와 데이터 변환에 이르기까지 전반적인 내용을 살펴보았다. 소켓은 단순히 데이터를 주고받는 통로를 넘어, IP 주소, 포트 번호, 바이트 정렬과 같은 복잡한 네트워크 개념을 프로그래머가 쉽게 다룰 수 있도록 도와주는 추상적인 도구라는 것을 알 수 있었다. 
 